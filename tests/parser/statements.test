# Parser Tests: Statements
# Format:
#   # test: name
#   # expect: ok | error
#   ---
#   input
#   ---
#   expected AST (S-expression) or error message
#   ===

# ============================================================
# ASSIGNMENTS
# ============================================================

# test: assign_int
# expect: ok
---
set X = 5
---
(assign X (int 5) local=false)
===

# test: assign_negative_int
# expect: ok
---
set X = -42
---
(assign X (int -42) local=false)
===

# test: assign_float
# expect: ok
---
set PI = 3.14159
---
(assign PI (float 3.14159) local=false)
===

# test: assign_bool_true
# expect: ok
---
set FLAG = true
---
(assign FLAG (bool true) local=false)
===

# test: assign_bool_false
# expect: ok
---
set FLAG = false
---
(assign FLAG (bool false) local=false)
===

# test: assign_string
# expect: ok
---
set NAME = "alice"
---
(assign NAME (string "alice") local=false)
===

# test: assign_string_with_spaces
# expect: ok
---
set MSG = "hello world"
---
(assign MSG (string "hello world") local=false)
===

# test: assign_string_with_escapes
# expect: ok
---
set MSG = "line\nbreak"
---
(assign MSG (string "line\nbreak") local=false)
===

# test: assign_array_empty
# expect: ok
---
set LIST = []
---
(assign LIST (array) local=false)
===

# test: assign_array_ints
# expect: ok
---
set NUMS = [1, 2, 3]
---
(assign NUMS (array (int 1) (int 2) (int 3)) local=false)
===

# test: assign_array_mixed
# expect: ok
---
set MIX = [1, "two", true]
---
(assign MIX (array (int 1) (string "two") (bool true)) local=false)
===

# test: assign_object_empty
# expect: ok
---
set OBJ = {}
---
(assign OBJ (object) local=false)
===

# test: assign_varref
# expect: ok
---
set Y = ${X}
---
(assign Y (varref X) local=false)
===

# test: assign_simple_varref
# expect: ok
---
set Y = $X
---
(assign Y (varref X) local=false)
===

# test: assign_interpolated
# expect: ok
---
set MSG = "hello ${NAME}"
---
(assign MSG (interpolated "hello " (varref NAME)) local=false)
===

# test: assign_interpolated_simple
# expect: ok
---
set MSG = "hello $NAME"
---
(assign MSG (interpolated "hello " (varref NAME)) local=false)
===

# test: assign_single_quoted
# expect: ok
---
set MSG = 'hello $NAME'
---
(assign MSG (string "hello $NAME") local=false)
===

# test: bash_assign_int
# expect: ok
# bourne: yes
---
X=5
---
(assign X (int 5) local=false)
===

# test: bash_assign_string
# expect: ok
# bourne: yes
---
NAME="alice"
---
(assign NAME (string "alice") local=false)
===

# test: local_assign_int
# expect: ok
---
local X = 5
---
(assign X (int 5) local=true)
===

# test: local_assign_string
# expect: ok
---
local MSG = "hello"
---
(assign MSG (string "hello") local=true)
===

# ============================================================
# COMMANDS
# ============================================================

# test: cmd_simple
# expect: ok
# bourne: yes
---
echo
---
(cmd echo)
===

# test: cmd_positional_string
# expect: ok
# bourne: yes
---
echo "hello"
---
(cmd echo (pos (string "hello")))
===

# test: cmd_positional_multiple
# expect: ok
# bourne: yes
---
echo "hello" "world"
---
(cmd echo (pos (string "hello")) (pos (string "world")))
===

# test: cmd_named_int
# expect: ok
---
fetch count=10
---
(cmd fetch (named count (int 10)))
===

# test: cmd_named_string
# expect: ok
---
search query="rust"
---
(cmd search (named query (string "rust")))
===

# test: cmd_named_multiple
# expect: ok
---
api endpoint="/users" limit=50 verbose=true
---
(cmd api (named endpoint (string "/users")) (named limit (int 50)) (named verbose (bool true)))
===

# test: cmd_mixed_args
# expect: ok
---
grep "pattern" path="/src" context=3
---
(cmd grep (pos (string "pattern")) (named path (string "/src")) (named context (int 3)))
===

# ============================================================
# PIPELINES
# ============================================================

# test: pipe_two
# expect: ok
# bourne: yes
---
a | b
---
(pipeline (cmd a) (cmd b))
===

# test: pipe_three
# expect: ok
---
cat file | grep "pattern" | head 10
---
(pipeline (cmd cat (pos (string "file"))) (cmd grep (pos (string "pattern"))) (cmd head (pos (int 10))))
===

# test: pipe_with_args
# expect: ok
---
ls path="/src" | grep pattern="\.rs$" | wc
---
(pipeline
  (cmd ls (named path (string "/src")))
  (cmd grep (named pattern (string "\\.rs$")))
  (cmd wc))
===

# test: pipe_background
# expect: ok
---
slow-task &
---
(background (cmd slow-task))
===

# test: pipe_chain_background
# expect: ok
---
a | b | c &
---
(background (pipeline (cmd a) (cmd b) (cmd c)))
===

# ============================================================
# REDIRECTS
# ============================================================

# test: redirect_stdout
# expect: ok
# bourne: yes
---
echo "hello" > /tmp/out
---
(cmd echo (pos (string "hello")) (redir > (string "/tmp/out")))
===

# test: redirect_append
# expect: ok
# bourne: yes
---
echo "more" >> /tmp/out
---
(cmd echo (pos (string "more")) (redir >> (string "/tmp/out")))
===

# test: redirect_stdin
# expect: ok
# bourne: yes
---
wc < /tmp/input
---
(cmd wc (redir < (string "/tmp/input")))
===

# test: redirect_stderr
# expect: ok
---
risky-cmd 2> /tmp/err
---
(cmd risky-cmd (redir 2> (string "/tmp/err")))
===

# test: redirect_both
# expect: ok
---
cmd &> /tmp/all
---
(cmd cmd (redir &> (string "/tmp/all")))
===

# test: redirect_multiple
# expect: ok
---
cmd < /in > /out 2> /err
---
(cmd cmd (redir < (string "/in")) (redir > (string "/out")) (redir 2> (string "/err")))
===

# test: redirect_in_pipeline
# expect: ok
---
a | b > /out
---
(pipeline (cmd a) (cmd b (redir > (string "/out"))))
===

# ============================================================
# CONTROL FLOW
# ============================================================

# test: if_simple
# expect: ok
---
if ${?.ok}; then
    echo "yes"
fi
---
(if (varref ?.ok) (then (cmd echo (pos (string "yes")))) (else))
===

# test: if_else
# expect: ok
---
if ${?.ok}; then
    echo "yes"
else
    echo "no"
fi
---
(if (varref ?.ok) (then (cmd echo (pos (string "yes")))) (else (cmd echo (pos (string "no")))))
===

# test: if_command_condition
# expect: ok
---
if test-something; then
    echo "passed"
fi
---
(if (cmd test-something) (then (cmd echo (pos (string "passed")))) (else))
===

# test: if_comparison
# expect: ok
---
if (${X} > 5); then
    echo "big"
fi
---
(if (cmp > (varref X) (int 5)) (then (cmd echo (pos (string "big")))) (else))
===

# test: for_simple
# expect: ok
---
for X in ${LIST}; do
    echo ${X}
done
---
(for X (in (varref LIST)) (do (cmd echo (pos (varref X)))))
===

# test: for_array_literal
# expect: KNOWN_FAILURE arrays removed for bash compatibility
---
for N in [1, 2, 3]; do
    echo ${N}
done
---
(for N (array (int 1) (int 2) (int 3)) (do (cmd echo (pos (varref N)))))
===

# test: and_chain
# expect: ok
---
a && b && c
---
(and-chain (and-chain (cmd a) (cmd b)) (cmd c))
===

# test: or_chain
# expect: ok
---
a || b || c
---
(or-chain (or-chain (cmd a) (cmd b)) (cmd c))
===

# test: mixed_chain
# expect: ok
---
a && b || c
---
(or-chain (and-chain (cmd a) (cmd b)) (cmd c))
===

# ============================================================
# TOOL DEFINITIONS
# ============================================================

# test: tool_minimal
# expect: ok
---
tool noop {
}
---
(tooldef noop () ())
===

# test: tool_one_param
# expect: ok
---
tool greet name:string {
    echo "hello ${name}"
}
---
(tooldef greet ((param name string)) ((cmd echo (pos (interpolated "hello " (varref name))))))
===

# test: tool_multiple_params
# expect: ok
---
tool fetch url:string timeout:int retries:int {
    http-get url=${url} timeout=${timeout}
}
---
(tooldef fetch
  ((param url string) (param timeout int) (param retries int))
  ((cmd http-get (named url (varref url)) (named timeout (varref timeout)))))
===

# test: tool_default_values
# expect: ok
---
tool search query:string limit:int=10 offset:int=0 {
    db-query q=${query} l=${limit} o=${offset}
}
---
(tooldef search
  ((param query string) (param limit int (int 10)) (param offset int (int 0)))
  ((cmd db-query (named q (varref query)) (named l (varref limit)) (named o (varref offset)))))
===

# test: tool_typed_array
# expect: ok
---
tool multi items:array {
    echo ${items}
}
---
(tooldef multi ((param items array)) ((cmd echo (pos (varref items)))))
===

# test: tool_typed_object
# expect: ok
---
tool config opts:object {
    apply ${opts}
}
---
(tooldef config ((param opts object)) ((cmd apply (pos (varref opts)))))
===

# ============================================================
# SCATTER/GATHER
# ============================================================

# test: scatter_basic
# expect: ok
---
cat input | scatter | process | gather
---
(pipeline (cmd cat (pos (string "input"))) (cmd scatter) (cmd process) (cmd gather))
===

# test: scatter_with_as
# expect: ok
---
cat input | scatter as=ITEM | process ${ITEM} | gather
---
(pipeline
  (cmd cat (pos (string "input")))
  (cmd scatter (named as (string "ITEM")))
  (cmd process (pos (varref ITEM)))
  (cmd gather))
===

# test: scatter_with_limit
# expect: ok
---
cat input | scatter as=X limit=4 | process ${X} | gather
---
(pipeline
  (cmd cat (pos (string "input")))
  (cmd scatter (named as (string "X")) (named limit (int 4)))
  (cmd process (pos (varref X)))
  (cmd gather))
===

# test: gather_with_options
# expect: ok
---
cat input | scatter | process | gather progress=true errors="/tmp/err"
---
(pipeline
  (cmd cat (pos (string "input")))
  (cmd scatter)
  (cmd process)
  (cmd gather (named progress (bool true)) (named errors (string "/tmp/err"))))
===

# ============================================================
# TEST EXPRESSIONS [[ ]]
# ============================================================

# test: test_file_exists
# expect: ok
# bourne: yes
---
[[ -f /etc/hosts ]]
---
(test (file -f (string "/etc/hosts")))
===

# test: test_file_dir
# expect: ok
# bourne: yes
---
[[ -d /tmp ]]
---
(test (file -d (string "/tmp")))
===

# test: test_string_empty
# expect: ok
# bourne: yes
---
[[ -z $VAR ]]
---
(test (string -z (varref VAR)))
===

# test: test_string_nonempty
# expect: ok
# bourne: yes
---
[[ -n $VAR ]]
---
(test (string -n (varref VAR)))
===

# test: test_comparison_eq
# expect: ok
# bourne: yes
---
[[ $X == "value" ]]
---
(test (cmp == (varref X) (string "value")))
===

# test: test_comparison_neq
# expect: ok
# bourne: yes
---
[[ $X != "other" ]]
---
(test (cmp != (varref X) (string "other")))
===

# test: test_comparison_gt
# expect: ok
---
[[ $NUM -gt 5 ]]
---
(test (cmp -gt (varref NUM) (int 5)))
===

# test: test_comparison_lt
# expect: ok
---
[[ $NUM -lt 10 ]]
---
(test (cmp -lt (varref NUM) (int 10)))
===

# ============================================================
# STATEMENT CHAINING
# ============================================================

# test: stmt_and_chain
# expect: ok
# bourne: yes
---
cmd1 && cmd2
---
(and-chain (cmd cmd1) (cmd cmd2))
===

# test: stmt_or_chain
# expect: ok
# bourne: yes
---
cmd1 || cmd2
---
(or-chain (cmd cmd1) (cmd cmd2))
===

# test: stmt_chain_three
# expect: ok
# bourne: yes
---
mkdir dir && cd dir && init
---
(and-chain (and-chain (cmd mkdir (pos (string "dir"))) (cmd cd (pos (string "dir")))) (cmd init))
===

# test: stmt_chain_mixed
# expect: ok
# bourne: yes
---
try-primary || try-fallback || echo "failed"
---
(or-chain (or-chain (cmd try-primary) (cmd try-fallback)) (cmd echo (pos (string "failed"))))
===

# ============================================================
# EDGE CASES: AMBIGUITY RESOLUTION
# ============================================================

# test: keyword_as_variable_rejected
# expect: error
# Keywords are reserved - they cannot be used as variable names
---
if="value"
---
error: 'if' is a keyword
===

# test: keyword_while_rejected
# expect: error
---
while=true
---
error: 'while' is a keyword
===

# test: keyword_then_rejected
# expect: error
---
then="next"
---
error: 'then' is a keyword
===

# test: non_keyword_works
# expect: ok
# Names that contain keywords but aren't keywords work fine
---
myif="value"
---
(assign myif (string "value") local=false)
===

# test: keyword_at_stmt_start_is_keyword
# expect: ok
# 'if' at statement start is keyword (as expected)
---
if true; then echo; fi
---
(if (bool true) (then (cmd echo)) (else))
===

# ============================================================
# EDGE CASES: TEST EXPRESSIONS
# ============================================================

# test: test_expr_empty
# expect: error
# Empty [[ ]] is an error
---
[[ ]]
---
error: empty test expression
===

# test: test_expr_file_exists
# expect: ok
# Paths must be quoted strings
---
[[ -e "/path" ]]
---
(test (file -e (string "/path")))
===

# test: test_expr_is_file
# expect: ok
---
[[ -f "/path/file" ]]
---
(test (file -f (string "/path/file")))
===

# test: test_expr_is_dir
# expect: ok
---
[[ -d "/path/dir" ]]
---
(test (file -d (string "/path/dir")))
===

# test: test_expr_string_empty
# expect: ok
---
[[ -z $VAR ]]
---
(test (string -z (varref VAR)))
===

# test: test_expr_string_nonempty
# expect: ok
---
[[ -n $VAR ]]
---
(test (string -n (varref VAR)))
===

# test: test_expr_comparison_eq
# expect: ok
---
[[ $X == "value" ]]
---
(test (cmp == (varref X) (string "value")))
===

# test: test_expr_comparison_ne
# expect: ok
---
[[ $X != "other" ]]
---
(test (cmp != (varref X) (string "other")))
===

# test: test_expr_comparison_gt
# expect: ok
---
[[ $NUM -gt 5 ]]
---
(test (cmp -gt (varref NUM) (int 5)))
===

# test: test_expr_comparison_lt
# expect: ok
---
[[ $NUM -lt 10 ]]
---
(test (cmp -lt (varref NUM) (int 10)))
===

# test: test_expr_comparison_ge
# expect: ok
---
[[ $NUM -ge 5 ]]
---
(test (cmp -ge (varref NUM) (int 5)))
===

# test: test_expr_comparison_le
# expect: ok
---
[[ $NUM -le 10 ]]
---
(test (cmp -le (varref NUM) (int 10)))
===

# test: test_expr_regex_match
# expect: ok
---
[[ $filename =~ "\.rs$" ]]
---
(test (cmp match (varref filename) (string "\.rs$")))
===

# test: nested_array_not_test
# expect: ok
# [[1,2],[3,4]] is a nested array, not a test expression
---
cmd [[1, 2], [3, 4]]
---
(cmd cmd (pos (array (array (int 1) (int 2)) (array (int 3) (int 4)))))
===

# ============================================================
# EDGE CASES: SET COMMAND VS ASSIGNMENT
# ============================================================

# test: set_command_with_flag_e
# expect: ok
# bourne: yes
---
set -e
---
(cmd set (shortflag e))
===

# test: set_command_with_plus_flag
# expect: ok
---
set +e
---
(cmd set (pos (string "+e")))
===

# test: set_command_multiple_flags
# expect: ok
---
set -e -u
---
(cmd set (shortflag e) (shortflag u))
===

# test: set_command_no_args
# expect: ok
---
set
---
(cmd set)
===

# test: set_assignment_legacy
# expect: ok
# set X = value is the legacy assignment form
---
set X = 5
---
(assign X (int 5) local=false)
===

# test: set_in_chain
# expect: ok
---
set -e && echo "strict mode"
---
(and-chain (cmd set (shortflag e)) (cmd echo (pos (string "strict mode"))))
===

# ============================================================
# EDGE CASES: COMMAND NAMES
# ============================================================

# test: true_as_command
# expect: ok
# bourne: yes
---
true
---
(cmd true)
===

# test: false_as_command
# expect: ok
# bourne: yes
---
false
---
(cmd false)
===

# test: dot_as_source_alias
# expect: ok
---
. script.kai
---
(cmd . (pos (string "script.kai")))
===

# test: source_command
# expect: ok
---
source utils.kai
---
(cmd source (pos (string "utils.kai")))
===

# test: true_in_condition
# expect: ok
---
if true; then echo "yes"; fi
---
(if (bool true) (then (cmd echo (pos (string "yes")))) (else))
===

# test: false_in_condition
# expect: ok
---
if false; then echo "no"; fi
---
(if (bool false) (then (cmd echo (pos (string "no")))) (else))
===

# ============================================================
# EDGE CASES: ARGUMENT PARSING
# ============================================================

# test: named_arg_no_spaces
# expect: ok
---
cmd key=value
---
(cmd cmd (named key (string "value")))
===

# test: named_arg_with_spaces_error
# expect: error
# Spaces around = make it invalid
---
cmd key = value
---
error: unexpected '='
===

# test: long_flag_with_value
# expect: ok
---
git commit --message="hello"
---
(cmd git (pos (string "commit")) (named message (string "hello")))
===

# test: short_flag_then_value
# expect: ok
# -m and "msg" are separate args (flag doesn't consume next)
---
git commit -m "msg"
---
(cmd git (pos (string "commit")) (shortflag m) (pos (string "msg")))
===

# test: double_dash_ends_flags
# expect: ok
---
cmd -- -not-a-flag
---
(cmd cmd (pos (string "--")) (shortflag not-a-flag))
===

# ============================================================
# CASE STATEMENTS
# ============================================================

# test: case_simple
# expect: ok
---
case "hello" in
    hello) echo "matched" ;;
esac
---
(case (string "hello") ((branch "hello" ((cmd echo (pos (string "matched")))))))
===

# test: case_multiple_branches
# expect: ok
---
case ${X} in
    foo) echo "foo" ;;
    bar) echo "bar" ;;
esac
---
(case (varref X) ((branch "foo" ((cmd echo (pos (string "foo"))))) (branch "bar" ((cmd echo (pos (string "bar")))))))
===

# test: case_with_patterns
# expect: ok
---
case "test.rs" in
    "*.py") echo "Python" ;;
    "*.rs") echo "Rust" ;;
esac
---
(case (string "test.rs") ((branch "*.py" ((cmd echo (pos (string "Python"))))) (branch "*.rs" ((cmd echo (pos (string "Rust")))))))
===

# test: case_multiple_patterns
# expect: ok
---
case "y" in
    "y"|"yes") echo "yes" ;;
esac
---
(case (string "y") ((branch "y|yes" ((cmd echo (pos (string "yes")))))))
===

# test: case_with_default
# expect: ok
---
case "x" in
    "*") echo "default" ;;
esac
---
(case (string "x") ((branch "*" ((cmd echo (pos (string "default")))))))
===

# test: case_optional_lparen
# expect: ok
---
case "x" in
    (foo) echo "foo" ;;
esac
---
(case (string "x") ((branch "foo" ((cmd echo (pos (string "foo")))))))
===
