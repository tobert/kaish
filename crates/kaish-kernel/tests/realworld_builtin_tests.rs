//! Real-world builtin command tests
//!
//! These tests are derived from actual Claude Code session transcripts
//! (2024-2026) to ensure kaish builtins match real-world usage patterns.
//!
//! ## Methodology
//!
//! Tests were generated by mining command patterns from Claude Code sessions:
//!
//! ```bash
//! # Extract all Bash tool calls from session transcripts
//! for f in ~/.claude/projects/*/*.jsonl; do
//!   jq -r 'select(.type == "assistant") | .message.content[]?
//!          | select(.type == "tool_use" and .name == "Bash")
//!          | .input.command' "$f" 2>/dev/null
//! done > /tmp/all-bash-commands.txt
//!
//! # Count: 31,463 commands across all projects
//! # Top commands: cargo, git, grep (1036), ls (614), cat (298), echo (271),
//! #               find (260), curl (195), tail (134), wc (71)
//! ```
//!
//! ## Anonymization
//!
//! Raw patterns contain real file paths (e.g., `/home/atobey/src/project/...`).
//! Tests use **synthetic paths** (`/src/main.rs`, `/tmp/app.log`) that capture
//! the **command structure** without exposing actual project files.
//!
//! Example transformation:
//! - Real: `grep -A10 "pub fn encode" ~/.cargo/registry/src/.../diamond-types/...`
//! - Test: `grep -A10 "pub fn new" /src/api.rs`
//!
//! ## Bugs Found
//!
//! This test suite initially found 2 bugs (now fixed):
//!
//! 1. **ls single file** - `ls file.txt` failed with "not a directory"
//!    Real ls outputs the filename; we now check if path is a file first.
//!
//! 2. **wc multiple files** - `wc -l file1 file2` only output one line
//!    Real wc outputs per-file counts plus a total; now implemented.
//!
//! Source: ~/.claude/projects/*/*.jsonl (31,000+ bash commands analyzed)

use std::path::{Path, PathBuf};
use std::sync::Arc;

use kaish_kernel::ast::Value;
use kaish_kernel::tools::{register_builtins, ExecContext, ToolArgs, ToolRegistry};
use kaish_kernel::vfs::{Filesystem, MemoryFs, VfsRouter};

// ============================================================================
// Test Helpers
// ============================================================================

async fn make_registry() -> ToolRegistry {
    let mut registry = ToolRegistry::new();
    register_builtins(&mut registry);
    registry
}

async fn make_ctx() -> ExecContext {
    let mut vfs = VfsRouter::new();
    vfs.mount("/", MemoryFs::new());
    ExecContext::new(Arc::new(vfs))
}

async fn ctx_with_files() -> ExecContext {
    let mut vfs = VfsRouter::new();
    let mem = MemoryFs::new();

    // Create directory structure mimicking real project
    mem.mkdir(Path::new("src")).await.unwrap();
    mem.mkdir(Path::new("src/lib")).await.unwrap();
    mem.mkdir(Path::new("docs")).await.unwrap();
    mem.mkdir(Path::new("tmp")).await.unwrap();

    // Rust source files
    mem.write(
        Path::new("src/main.rs"),
        b"fn main() {\n    println!(\"Hello, world!\");\n    // TODO: add features\n}\n",
    )
    .await
    .unwrap();

    mem.write(
        Path::new("src/lib.rs"),
        b"//! Library crate\npub mod utils;\npub mod api;\n\n/// Main entry point\npub fn init() {\n    // TODO: implement\n}\n",
    )
    .await
    .unwrap();

    mem.write(
        Path::new("src/lib/utils.rs"),
        b"pub fn helper() -> String {\n    \"helper\".to_string()\n}\n\npub fn format_output(s: &str) -> String {\n    format!(\"[{}]\", s)\n}\n",
    )
    .await
    .unwrap();

    // Documentation
    mem.write(
        Path::new("README.md"),
        b"# Project\n\nA sample project for testing.\n\n## Features\n\n- Feature one\n- Feature two\n\n## TODO\n\n- Add more features\n",
    )
    .await
    .unwrap();

    mem.write(
        Path::new("docs/API.md"),
        b"# API Documentation\n\n## Functions\n\n### init()\n\nInitializes the system.\n\n### helper()\n\nReturns a helper string.\n",
    )
    .await
    .unwrap();

    mem.write(
        Path::new("CLAUDE.md"),
        b"# Claude Instructions\n\nThis project uses kaish shell.\n\n## Build\n\ncargo build\ncargo test\n",
    )
    .await
    .unwrap();

    // Config/data files
    mem.write(
        Path::new("Cargo.toml"),
        b"[package]\nname = \"example\"\nversion = \"0.1.0\"\nedition = \"2021\"\n\n[dependencies]\ntokio = \"1.0\"\n",
    )
    .await
    .unwrap();

    // JSON files (for jq tests and cat tests)
    mem.write(
        Path::new("tmp/data.json"),
        br#"{"name": "Alice", "age": 30, "active": true}"#,
    )
    .await
    .unwrap();

    mem.write(
        Path::new("tmp/array.json"),
        br#"[{"id": 1, "name": "one"}, {"id": 2, "name": "two"}, {"id": 3, "name": "three"}]"#,
    )
    .await
    .unwrap();

    mem.write(
        Path::new("tmp/settings.json"),
        br#"{"mcpServers": {"holler": {"url": "http://localhost:8080"}, "sshwarma": {"url": "http://localhost:3000"}}}"#,
    )
    .await
    .unwrap();

    // Log file (for tail/head tests)
    mem.write(
        Path::new("tmp/app.log"),
        b"2026-01-25T10:00:00 INFO Starting application\n\
          2026-01-25T10:00:01 DEBUG Loading config\n\
          2026-01-25T10:00:02 INFO Config loaded successfully\n\
          2026-01-25T10:00:03 WARN Deprecated feature used\n\
          2026-01-25T10:00:04 ERROR Connection failed\n\
          2026-01-25T10:00:05 INFO Retrying connection\n\
          2026-01-25T10:00:06 INFO Connected\n\
          2026-01-25T10:00:07 DEBUG Processing request\n\
          2026-01-25T10:00:08 INFO Request completed\n\
          2026-01-25T10:00:09 INFO Shutting down\n",
    )
    .await
    .unwrap();

    // Multi-line source for context tests
    mem.write(
        Path::new("src/api.rs"),
        b"use std::sync::Arc;\n\
          \n\
          pub struct Api {\n\
              pub name: String,\n\
          }\n\
          \n\
          impl Api {\n\
              pub fn new(name: &str) -> Self {\n\
                  Self { name: name.to_string() }\n\
              }\n\
              \n\
              pub async fn execute(&self) -> Result<(), Error> {\n\
                  // TODO: implement\n\
                  Ok(())\n\
              }\n\
          }\n",
    )
    .await
    .unwrap();

    vfs.mount("/", mem);
    ExecContext::new(Arc::new(vfs))
}

// ============================================================================
// GREP Tests - Real-world patterns from Claude Code sessions
// ============================================================================

mod grep_realworld {
    use super::*;

    // Pattern: grep -A 10 "pattern" file.rs
    // Source: Frequently used to find function definitions with context
    #[tokio::test]
    async fn test_grep_after_context_function_definition() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("pub fn new".into()));
        args.positional.push(Value::String("/src/api.rs".into()));
        args.named.insert("after_context".to_string(), Value::Int(5));

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -A failed: {}", result.err);
        assert!(result.out.contains("pub fn new"));
        assert!(result.out.contains("name.to_string()")); // Context line
    }

    // Pattern: grep -E "pattern\|pattern2" file
    // Source: Common for finding multiple related patterns
    #[tokio::test]
    async fn test_grep_alternation_pattern() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("TODO|FIXME".into()));
        args.positional.push(Value::String("/src/main.rs".into()));
        args.flags.insert("E".to_string()); // Extended regex

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -E alternation failed: {}", result.err);
        assert!(result.out.contains("TODO"));
    }

    // Pattern: grep -r "pattern" directory/
    // Source: Used extensively for codebase searches
    #[tokio::test]
    async fn test_grep_recursive_in_src() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("TODO".into()));
        args.positional.push(Value::String("/src".into()));
        args.flags.insert("r".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -r failed: {}", result.err);
        // Should find TODO in multiple files
        assert!(result.out.contains("main.rs") || result.out.contains("lib.rs") || result.out.contains("api.rs"));
    }

    // Pattern: grep -l "pattern" *.rs
    // Source: Finding which files contain a pattern
    #[tokio::test]
    async fn test_grep_files_with_matches() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("TODO".into()));
        args.positional.push(Value::String("/src".into()));
        args.flags.insert("r".to_string());
        args.flags.insert("l".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -rl failed: {}", result.err);
        // Output should be filenames only
        for line in result.out.lines() {
            assert!(line.ends_with(".rs"), "Expected filename, got: {}", line);
        }
    }

    // Pattern: grep -n "pattern" file
    // Source: Finding line numbers for navigation
    #[tokio::test]
    async fn test_grep_with_line_numbers() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("impl".into()));
        args.positional.push(Value::String("/src/api.rs".into()));
        args.flags.insert("n".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -n failed: {}", result.err);
        // Should have line number prefix
        assert!(result.out.contains(":"));
        // Line should contain the pattern
        assert!(result.out.contains("impl"));
    }

    // Pattern: grep -i "error" logfile
    // Source: Case-insensitive log searching
    #[tokio::test]
    async fn test_grep_case_insensitive_log_search() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("error".into()));
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.flags.insert("i".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -i failed: {}", result.err);
        assert!(result.out.contains("ERROR")); // Finds ERROR even with lowercase pattern
    }

    // Pattern: grep -c "pattern" file
    // Source: Counting occurrences
    #[tokio::test]
    async fn test_grep_count_matches() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("INFO".into()));
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.flags.insert("c".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -c failed: {}", result.err);
        let count: i32 = result.out.trim().parse().unwrap_or(-1);
        assert!(count > 0, "Expected positive count, got: {}", result.out);
    }

    // Pattern: grep -v "pattern" file
    // Source: Filtering out lines (inverse match)
    #[tokio::test]
    async fn test_grep_invert_match() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("DEBUG".into()));
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.flags.insert("v".to_string());

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep -v failed: {}", result.err);
        // Should NOT contain DEBUG lines
        assert!(!result.out.contains("DEBUG"));
        // But should contain other lines
        assert!(result.out.contains("INFO") || result.out.contains("ERROR"));
    }

    // Pattern: grep "pattern" file | head -10
    // Simulated: grep from stdin (piped data)
    #[tokio::test]
    async fn test_grep_from_stdin() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;
        ctx.set_stdin("line one\nline two\nline three\nfour\nfive\n".to_string());

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("line".into()));

        let result = grep.execute(args, &mut ctx).await;
        assert!(result.ok(), "grep stdin failed: {}", result.err);
        assert_eq!(result.out.lines().count(), 3); // three lines contain "line"
    }
}

// ============================================================================
// CAT Tests - Real-world patterns
// ============================================================================

mod cat_realworld {
    use super::*;

    // Pattern: cat file.json
    // Source: Reading JSON config files
    #[tokio::test]
    async fn test_cat_json_file() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/settings.json".into()));

        let result = cat.execute(args, &mut ctx).await;
        assert!(result.ok(), "cat json failed: {}", result.err);
        assert!(result.out.contains("mcpServers"));
        assert!(result.out.contains("holler"));
    }

    // Pattern: cat ~/.config/file.toml
    // Source: Reading TOML config
    #[tokio::test]
    async fn test_cat_toml_file() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/Cargo.toml".into()));

        let result = cat.execute(args, &mut ctx).await;
        assert!(result.ok(), "cat toml failed: {}", result.err);
        assert!(result.out.contains("[package]"));
        assert!(result.out.contains("[dependencies]"));
    }

    // Pattern: cat file1 file2 file3
    // Source: Concatenating multiple files
    #[tokio::test]
    async fn test_cat_multiple_files() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/main.rs".into()));
        args.positional.push(Value::String("/src/lib.rs".into()));

        let result = cat.execute(args, &mut ctx).await;
        assert!(result.ok(), "cat multiple failed: {}", result.err);
        assert!(result.out.contains("fn main")); // from main.rs
        assert!(result.out.contains("pub mod utils")); // from lib.rs
    }

    // Pattern: cat -n file.rs
    // Source: Viewing with line numbers for reference
    #[tokio::test]
    async fn test_cat_with_line_numbers() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/main.rs".into()));
        args.flags.insert("n".to_string());

        let result = cat.execute(args, &mut ctx).await;
        assert!(result.ok(), "cat -n failed: {}", result.err);
        // Should have line number prefix
        assert!(result.out.contains("1") || result.out.contains("2"));
    }

    // Pattern: cat nonexistent 2>/dev/null || echo "Not found"
    // Test: cat on nonexistent file should fail
    #[tokio::test]
    async fn test_cat_nonexistent_file() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/nonexistent/file.txt".into()));

        let result = cat.execute(args, &mut ctx).await;
        assert!(!result.ok());
    }
}

// ============================================================================
// HEAD Tests - Real-world patterns
// ============================================================================

mod head_realworld {
    use super::*;

    // Pattern: head -100 file.log
    // Source: Looking at start of log files
    #[tokio::test]
    async fn test_head_log_file() {
        let registry = make_registry().await;
        let head = registry.get("head").expect("head not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.named.insert("lines".to_string(), Value::Int(5));

        let result = head.execute(args, &mut ctx).await;
        assert!(result.ok(), "head failed: {}", result.err);
        assert_eq!(result.out.lines().count(), 5);
        assert!(result.out.contains("Starting application")); // First line
    }

    // Pattern: head -20 src/file.rs
    // Source: Quick file preview
    #[tokio::test]
    async fn test_head_source_file() {
        let registry = make_registry().await;
        let head = registry.get("head").expect("head not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/api.rs".into()));
        args.named.insert("lines".to_string(), Value::Int(3));

        let result = head.execute(args, &mut ctx).await;
        assert!(result.ok(), "head src failed: {}", result.err);
        assert_eq!(result.out.lines().count(), 3);
        assert!(result.out.contains("use std::sync::Arc"));
    }

    // Pattern: head -n 10 file (using -n flag)
    #[tokio::test]
    async fn test_head_with_n_flag() {
        let registry = make_registry().await;
        let head = registry.get("head").expect("head not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.flags.insert("n".to_string());
        // The number should be parsed from positional or named
        args.named.insert("n".to_string(), Value::Int(3));

        let result = head.execute(args, &mut ctx).await;
        assert!(result.ok(), "head -n failed: {}", result.err);
        assert!(result.out.lines().count() <= 3);
    }

    // Default: head file (should show 10 lines)
    #[tokio::test]
    async fn test_head_default_lines() {
        let registry = make_registry().await;
        let head = registry.get("head").expect("head not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/app.log".into()));

        let result = head.execute(args, &mut ctx).await;
        assert!(result.ok(), "head default failed: {}", result.err);
        // Log has 10 lines, default should show all or 10
        assert!(result.out.lines().count() <= 10);
    }
}

// ============================================================================
// TAIL Tests - Real-world patterns
// ============================================================================

mod tail_realworld {
    use super::*;

    // Pattern: tail -100 file.log
    // Source: Looking at recent log entries
    #[tokio::test]
    async fn test_tail_log_file() {
        let registry = make_registry().await;
        let tail = registry.get("tail").expect("tail not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/app.log".into()));
        args.named.insert("lines".to_string(), Value::Int(5));

        let result = tail.execute(args, &mut ctx).await;
        assert!(result.ok(), "tail failed: {}", result.err);
        assert_eq!(result.out.lines().count(), 5);
        assert!(result.out.contains("Shutting down")); // Last line
    }

    // Pattern: tail -15 typescript
    // Source: Checking terminal recording output
    #[tokio::test]
    async fn test_tail_source_file() {
        let registry = make_registry().await;
        let tail = registry.get("tail").expect("tail not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/api.rs".into()));
        args.named.insert("lines".to_string(), Value::Int(3));

        let result = tail.execute(args, &mut ctx).await;
        assert!(result.ok(), "tail src failed: {}", result.err);
        assert_eq!(result.out.lines().count(), 3);
    }

    // Default: tail file (should show 10 lines)
    #[tokio::test]
    async fn test_tail_default_lines() {
        let registry = make_registry().await;
        let tail = registry.get("tail").expect("tail not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/tmp/app.log".into()));

        let result = tail.execute(args, &mut ctx).await;
        assert!(result.ok(), "tail default failed: {}", result.err);
        assert!(result.out.lines().count() <= 10);
    }
}

// ============================================================================
// WC Tests - Real-world patterns
// ============================================================================

mod wc_realworld {
    use super::*;

    // Pattern: wc -l file.rs
    // Source: Checking file sizes
    #[tokio::test]
    async fn test_wc_lines_single_file() {
        let registry = make_registry().await;
        let wc = registry.get("wc").expect("wc not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/api.rs".into()));
        args.flags.insert("l".to_string());

        let result = wc.execute(args, &mut ctx).await;
        assert!(result.ok(), "wc -l failed: {}", result.err);
        // Should output line count
        let count: i32 = result.out.split_whitespace().next().unwrap_or("0").parse().unwrap_or(-1);
        assert!(count > 0, "Expected positive line count");
    }

    // Pattern: wc -l file1 file2 file3
    // Source: Comparing file sizes
    #[tokio::test]
    async fn test_wc_lines_multiple_files() {
        let registry = make_registry().await;
        let wc = registry.get("wc").expect("wc not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src/main.rs".into()));
        args.positional.push(Value::String("/src/lib.rs".into()));
        args.flags.insert("l".to_string());

        let result = wc.execute(args, &mut ctx).await;
        assert!(result.ok(), "wc -l multiple failed: {}", result.err);
        // Should have output for each file
        let lines: Vec<&str> = result.out.lines().collect();
        assert!(lines.len() >= 2, "Expected output for multiple files");
    }

    // Pattern: wc -l docs/*.md README.md CLAUDE.md
    // This tests glob expansion which may not be handled by wc directly
    #[tokio::test]
    async fn test_wc_markdown_files() {
        let registry = make_registry().await;
        let wc = registry.get("wc").expect("wc not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/README.md".into()));
        args.positional.push(Value::String("/CLAUDE.md".into()));
        args.flags.insert("l".to_string());

        let result = wc.execute(args, &mut ctx).await;
        assert!(result.ok(), "wc -l markdown failed: {}", result.err);
    }

    // Pattern: wc (no flags) - should show lines, words, bytes
    #[tokio::test]
    async fn test_wc_default_output() {
        let registry = make_registry().await;
        let wc = registry.get("wc").expect("wc not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/README.md".into()));

        let result = wc.execute(args, &mut ctx).await;
        assert!(result.ok(), "wc default failed: {}", result.err);
        // Default output should have multiple numbers
        let parts: Vec<&str> = result.out.split_whitespace().collect();
        assert!(parts.len() >= 3, "Expected lines, words, bytes");
    }
}

// ============================================================================
// LS Tests - Real-world patterns
// ============================================================================

mod ls_realworld {
    use super::*;

    // Pattern: ls src/
    // Source: Exploring directory structure
    #[tokio::test]
    async fn test_ls_directory() {
        let registry = make_registry().await;
        let ls = registry.get("ls").expect("ls not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src".into()));

        let result = ls.execute(args, &mut ctx).await;
        assert!(result.ok(), "ls failed: {}", result.err);
        assert!(result.out.contains("main.rs"));
        assert!(result.out.contains("lib.rs"));
    }

    // Pattern: ls -la directory/
    // Source: Detailed file listing
    #[tokio::test]
    async fn test_ls_long_all() {
        let registry = make_registry().await;
        let ls = registry.get("ls").expect("ls not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/src".into()));
        args.flags.insert("l".to_string());
        args.flags.insert("a".to_string());

        let result = ls.execute(args, &mut ctx).await;
        assert!(result.ok(), "ls -la failed: {}", result.err);
        // Long format should have more detail
        assert!(result.out.contains("main.rs"));
    }

    // Pattern: ls *.rs (would need glob expansion)
    // For now test explicit file
    #[tokio::test]
    async fn test_ls_single_file() {
        let registry = make_registry().await;
        let ls = registry.get("ls").expect("ls not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("/README.md".into()));

        let result = ls.execute(args, &mut ctx).await;
        assert!(result.ok(), "ls file failed: {}", result.err);
        assert!(result.out.contains("README.md"));
    }

    // Pattern: ls (current directory)
    #[tokio::test]
    async fn test_ls_cwd() {
        let registry = make_registry().await;
        let ls = registry.get("ls").expect("ls not found");
        let mut ctx = ctx_with_files().await;
        ctx.set_cwd(PathBuf::from("/src"));
        let args = ToolArgs::new();

        let result = ls.execute(args, &mut ctx).await;
        assert!(result.ok(), "ls cwd failed: {}", result.err);
        assert!(result.out.contains("main.rs") || result.out.contains("lib.rs"));
    }
}

// ============================================================================
// ECHO Tests - Real-world patterns
// ============================================================================

mod echo_realworld {
    use super::*;

    // Pattern: echo "message"
    #[tokio::test]
    async fn test_echo_simple_string() {
        let registry = make_registry().await;
        let echo = registry.get("echo").expect("echo not found");
        let mut ctx = make_ctx().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("Hello, world!".into()));

        let result = echo.execute(args, &mut ctx).await;
        assert!(result.ok(), "echo failed: {}", result.err);
        assert_eq!(result.out.trim(), "Hello, world!");
    }

    // Pattern: echo "---"
    // Source: Common separator in output
    #[tokio::test]
    async fn test_echo_separator() {
        let registry = make_registry().await;
        let echo = registry.get("echo").expect("echo not found");
        let mut ctx = make_ctx().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("---".into()));

        let result = echo.execute(args, &mut ctx).await;
        assert!(result.ok(), "echo separator failed: {}", result.err);
        assert_eq!(result.out.trim(), "---");
    }

    // Pattern: echo "" (empty string)
    #[tokio::test]
    async fn test_echo_empty() {
        let registry = make_registry().await;
        let echo = registry.get("echo").expect("echo not found");
        let mut ctx = make_ctx().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("".into()));

        let result = echo.execute(args, &mut ctx).await;
        assert!(result.ok(), "echo empty failed: {}", result.err);
    }

    // Pattern: echo "multiple" "arguments"
    #[tokio::test]
    async fn test_echo_multiple_args() {
        let registry = make_registry().await;
        let echo = registry.get("echo").expect("echo not found");
        let mut ctx = make_ctx().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("Hello".into()));
        args.positional.push(Value::String("World".into()));

        let result = echo.execute(args, &mut ctx).await;
        assert!(result.ok(), "echo multiple failed: {}", result.err);
        assert!(result.out.contains("Hello"));
        assert!(result.out.contains("World"));
    }

    // Pattern: echo -n "no newline"
    #[tokio::test]
    async fn test_echo_no_newline() {
        let registry = make_registry().await;
        let echo = registry.get("echo").expect("echo not found");
        let mut ctx = make_ctx().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("no newline".into()));
        args.flags.insert("n".to_string());

        let result = echo.execute(args, &mut ctx).await;
        assert!(result.ok(), "echo -n failed: {}", result.err);
        assert!(!result.out.ends_with('\n'));
    }
}

// ============================================================================
// JQ Tests - Real-world patterns (extends jq_native tests)
// ============================================================================

mod jq_realworld {
    use super::*;

    // Pattern: jq '.field' file.json (positional file - the bug we fixed!)
    #[tokio::test]
    async fn test_jq_positional_file_basic() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String(".name".into()));
        args.positional.push(Value::String("/tmp/data.json".into()));

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq positional failed: {}", result.err);
        assert!(result.out.contains("Alice"));
    }

    // Pattern: jq '.[] | select(.id == 2)' file.json
    #[tokio::test]
    async fn test_jq_select_from_array() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String(".[] | select(.id == 2)".into()));
        args.positional.push(Value::String("/tmp/array.json".into()));

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq select failed: {}", result.err);
        assert!(result.out.contains("two"));
    }

    // Pattern: jq -r '.field' file.json
    #[tokio::test]
    async fn test_jq_raw_output_positional_file() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String(".name".into()));
        args.positional.push(Value::String("/tmp/data.json".into()));
        args.flags.insert("r".to_string());

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq -r failed: {}", result.err);
        assert_eq!(result.out.trim(), "Alice"); // No quotes with -r
    }

    // Pattern: jq 'length' file.json
    #[tokio::test]
    async fn test_jq_length_function() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String("length".into()));
        args.positional.push(Value::String("/tmp/array.json".into()));

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq length failed: {}", result.err);
        assert_eq!(result.out.trim(), "3");
    }

    // Pattern: jq '.mcpServers | keys' settings.json
    #[tokio::test]
    async fn test_jq_keys_function() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = ctx_with_files().await;

        let mut args = ToolArgs::new();
        args.positional.push(Value::String(".mcpServers | keys".into()));
        args.positional.push(Value::String("/tmp/settings.json".into()));

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq keys failed: {}", result.err);
        assert!(result.out.contains("holler"));
        assert!(result.out.contains("sshwarma"));
    }

    // Pattern: cat file.json | jq '.field' (stdin)
    #[tokio::test]
    async fn test_jq_from_stdin() {
        let registry = make_registry().await;
        let jq = registry.get("jq").expect("jq not found");
        let mut ctx = make_ctx().await;
        ctx.set_stdin(r#"{"name": "Bob", "value": 42}"#.to_string());

        let mut args = ToolArgs::new();
        args.positional.push(Value::String(".value".into()));

        let result = jq.execute(args, &mut ctx).await;
        assert!(result.ok(), "jq stdin failed: {}", result.err);
        assert_eq!(result.out.trim(), "42");
    }
}

// ============================================================================
// Pipeline Pattern Tests (simulated as sequential operations)
// ============================================================================

mod pipeline_patterns {
    use super::*;

    // Pattern: grep "pattern" file | wc -l
    #[tokio::test]
    async fn test_grep_pipe_wc() {
        let registry = make_registry().await;
        let grep = registry.get("grep").expect("grep not found");
        let wc = registry.get("wc").expect("wc not found");
        let mut ctx = ctx_with_files().await;

        // First: grep INFO from log
        let mut grep_args = ToolArgs::new();
        grep_args.positional.push(Value::String("INFO".into()));
        grep_args.positional.push(Value::String("/tmp/app.log".into()));

        let grep_result = grep.execute(grep_args, &mut ctx).await;
        assert!(grep_result.ok());

        // Second: pipe output to wc -l
        ctx.set_stdin(grep_result.out);
        let mut wc_args = ToolArgs::new();
        wc_args.flags.insert("l".to_string());

        let wc_result = wc.execute(wc_args, &mut ctx).await;
        assert!(wc_result.ok(), "wc failed: {}", wc_result.err);

        let count: i32 = wc_result.out.trim().parse().unwrap_or(0);
        assert!(count > 0, "Expected INFO lines");
    }

    // Pattern: cat file | grep "pattern"
    #[tokio::test]
    async fn test_cat_pipe_grep() {
        let registry = make_registry().await;
        let cat = registry.get("cat").expect("cat not found");
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        // First: cat the file
        let mut cat_args = ToolArgs::new();
        cat_args.positional.push(Value::String("/tmp/app.log".into()));

        let cat_result = cat.execute(cat_args, &mut ctx).await;
        assert!(cat_result.ok());

        // Second: grep for ERROR
        ctx.set_stdin(cat_result.out);
        let mut grep_args = ToolArgs::new();
        grep_args.positional.push(Value::String("ERROR".into()));

        let grep_result = grep.execute(grep_args, &mut ctx).await;
        assert!(grep_result.ok(), "grep failed: {}", grep_result.err);
        assert!(grep_result.out.contains("Connection failed"));
    }

    // Pattern: head -50 file | grep "pattern"
    #[tokio::test]
    async fn test_head_pipe_grep() {
        let registry = make_registry().await;
        let head = registry.get("head").expect("head not found");
        let grep = registry.get("grep").expect("grep not found");
        let mut ctx = ctx_with_files().await;

        // First: head
        let mut head_args = ToolArgs::new();
        head_args.positional.push(Value::String("/tmp/app.log".into()));
        head_args.named.insert("lines".to_string(), Value::Int(5));

        let head_result = head.execute(head_args, &mut ctx).await;
        assert!(head_result.ok());

        // Second: grep for DEBUG
        ctx.set_stdin(head_result.out);
        let mut grep_args = ToolArgs::new();
        grep_args.positional.push(Value::String("DEBUG".into()));

        let grep_result = grep.execute(grep_args, &mut ctx).await;
        assert!(grep_result.ok(), "grep failed: {}", grep_result.err);
        assert!(grep_result.out.contains("Loading config"));
    }
}
